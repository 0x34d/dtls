package dtls

import (
	"reflect"
	"testing"
	"time"
)

func TestHandshakeMessage(t *testing.T) {
	rawHandshakeMessage := []byte{
		0x01, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0xfd, 0xb6,
		0x2f, 0xce, 0x5c, 0x42, 0x54, 0xff, 0x86, 0xe1, 0x24, 0x41, 0x91, 0x42, 0x62, 0x15, 0xad,
		0x16, 0xc9, 0x15, 0x8d, 0x95, 0x71, 0x8a, 0xbb, 0x22, 0xd7, 0x47, 0xec, 0xd8, 0x3d, 0xdc,
		0x4b, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	parsedHandshake := &handshake{
		fragmentLength: 0x3F,
		handshakeMessage: &clientHello{
			version: protocolVersion{0xFE, 0xFD},
			random: handshakeRandom{
				time.Unix(3056586332, 0),
				[28]byte{0x42, 0x54, 0xff, 0x86, 0xe1, 0x24, 0x41, 0x91, 0x42, 0x62, 0x15, 0xad, 0x16, 0xc9, 0x15, 0x8d, 0x95, 0x71, 0x8a, 0xbb, 0x22, 0xd7, 0x47, 0xec, 0xd8, 0x3d, 0xdc, 0x4b},
			},
			cipherSuites:       []*cipherSuite{},
			compressionMethods: []*compressionMethod{},
		},
	}

	h := &handshake{}
	if err := h.unmarshal(rawHandshakeMessage); err != nil {
		t.Error(err)
	} else if !reflect.DeepEqual(h, parsedHandshake) {
		t.Errorf("clientHello unmarshal: got %#v, want %#v", h, parsedHandshake)
	}

	raw, err := h.marshal()
	if err != nil {
		t.Error(err)
	} else if !reflect.DeepEqual(raw, rawHandshakeMessage) {
		t.Errorf("clientHello marshal: got %#v, want %#v", raw, rawHandshakeMessage)
	}
}
